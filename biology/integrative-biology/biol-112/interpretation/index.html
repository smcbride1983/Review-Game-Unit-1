<!-- interpretation.html
     Figure Interpretation Game (image + MCQ + per-option hint toggles)
     Loads decks from: ./data/interpretation_decks.js

     Folder layout (recommended):
     interpretation/
       interpretation.html
       data/
         interpretation_decks.js
       images/
         figureF.png
         figureG.png
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Figure Interpretation Practice</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0f19; color: #e8eefc; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px; }
    .card { background: #111a2e; border: 1px solid #223255; border-radius: 14px; padding: 18px; box-shadow: 0 8px 22px rgba(0,0,0,.25); }
    h1 { margin: 0 0 10px; font-size: 22px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }

    select, button {
      background: #0f1730; color: #e8eefc; border: 1px solid #2a3b63;
      border-radius: 10px; padding: 10px 12px; font-size: 14px;
    }
    button { cursor: pointer; }
    button:disabled { opacity: .45; cursor: not-allowed; }

    .muted { color: #a8b6da; font-size: 13px; }
    .topbar { display:flex; justify-content:space-between; gap: 12px; flex-wrap: wrap; align-items:center; margin-bottom: 12px; }
    .pill { padding: 6px 10px; border-radius: 999px; background:#0f1730; border:1px solid #2a3b63; font-size: 13px; color:#cfe0ff; }
    .divider { height: 1px; background: #223255; margin: 14px 0; }

    /* Figure */
    .figureWrap { margin: 10px 0 14px; }
    .figureImg {
      width: 100%;
      max-height: 360px;
      object-fit: contain;
      border-radius: 12px;
      border: 1px solid #2a3b63;
      background: #0f1730;
    }

    .prompt { margin: 14px 0 12px; font-size: 16px; line-height: 1.35; }

    /* Choices */
    .choices { display: grid; gap: 10px; margin: 12px 0; }
    .choice {
      display: flex; gap: 10px; align-items: flex-start;
      padding: 12px; border-radius: 12px; border: 1px solid #2a3b63; background: #0f1730;
    }
    .choice input { transform: translateY(2px); }
    .choiceMain { flex: 1; }
    .choiceTop { display:flex; justify-content:space-between; gap: 10px; align-items:flex-start; }
    .choiceText b { font-weight: 700; }
    .hintBtn {
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 13px;
      border: 1px solid #2a3b63;
      background: #111a2e;
      color: #cfe0ff;
      cursor: pointer;
      white-space: nowrap;
    }
    .hintBtn:hover { background:#0f1730; }
    .hintBox {
      display: none;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px dashed #4463a3;
      background: rgba(15, 23, 48, .7);
      color: #cfe0ff;
      font-size: 13px;
      line-height: 1.35;
    }

    /* Feedback */
    .feedback { margin-top: 10px; padding: 10px 12px; border-radius: 12px; border: 1px solid transparent; }
    .ok { background: rgba(30, 140, 70, .15); border-color: rgba(30, 140, 70, .45); }
    .bad { background: rgba(200, 70, 70, .15); border-color: rgba(200, 70, 70, .45); }

    /* Small utilities */
    .srOnly { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <h1>Figure Interpretation Practice</h1>
        <div class="row">
          <span class="pill" id="statusPill">Not started</span>
          <span class="pill" id="scorePill">Score: 0/0</span>
        </div>
      </div>

      <div class="row">
        <label class="muted" for="deckSelect">Deck</label>
        <select id="deckSelect"></select>

        <label class="muted" for="categorySelect">Category</label>
        <select id="categorySelect" disabled>
          <option value="__ALL__">All categories</option>
        </select>

        <button id="startBtn">Start</button>
        <button id="restartBtn" disabled>Restart</button>
        
        <a href="../" class="btnLink">⬅ BIOL 112</a>
   
      </div>

      <div class="divider"></div>

      <div id="gameArea" style="display:none;">
        <div class="row" style="justify-content:space-between;">
          <div class="muted" id="progressText"></div>
          <div class="muted" id="categoryText"></div>
        </div>

        <div class="figureWrap" id="figureWrap" style="display:none;">
          <img id="figureImg" class="figureImg" alt="" />
          <div class="muted" id="figureCaption" style="margin-top:6px;"></div>
        </div>

        <div class="prompt" id="promptText"></div>

        <div class="choices" id="choicesArea" aria-label="Answer choices"></div>

        <div class="row">
          <button id="submitBtn" disabled>Submit</button>
          <button id="nextBtn" disabled>Next</button>
        </div>

        <div id="feedbackBox" class="feedback" style="display:none;"></div>
      </div>

      <div id="emptyState" class="muted">
        Choose a deck and click <b>Start</b>.
      </div>
    </div>
  </div>

  <!-- Load interpretation decks (path is relative to this HTML file) -->
  <script src="./data/interpretation_decks.js"></script>

  <script>
    // ---------- Helpers ----------
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function unique(arr) {
      return Array.from(new Set(arr));
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // ---------- State ----------
    const state = {
      deckName: null,
      category: "__ALL__",
      pool: [],
      order: [],
      idx: 0,
      correct: 0,
      total: 0,
      answered: false,
      current: null,
      // For each question, we shuffle displayed choice order but keep their objects
      displayChoices: []
    };

    // ---------- Elements ----------
    const deckSelect = document.getElementById("deckSelect");
    const categorySelect = document.getElementById("categorySelect");
    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");

    const gameArea = document.getElementById("gameArea");
    const emptyState = document.getElementById("emptyState");

    const figureWrap = document.getElementById("figureWrap");
    const figureImg = document.getElementById("figureImg");
    const figureCaption = document.getElementById("figureCaption");

    const promptText = document.getElementById("promptText");
    const choicesArea = document.getElementById("choicesArea");
    const submitBtn = document.getElementById("submitBtn");
    const nextBtn = document.getElementById("nextBtn");
    const feedbackBox = document.getElementById("feedbackBox");

    const progressText = document.getElementById("progressText");
    const categoryText = document.getElementById("categoryText");
    const statusPill = document.getElementById("statusPill");
    const scorePill = document.getElementById("scorePill");

    // ---------- Deck init ----------
    function initDecks() {
      const decks = window.INTERPRETATION_DECKS || {};
      const names = Object.keys(decks).sort();

      deckSelect.innerHTML = "";
      if (names.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No decks loaded";
        deckSelect.appendChild(opt);
        startBtn.disabled = true;
        categorySelect.disabled = true;
        return;
      }

      for (const name of names) {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        deckSelect.appendChild(opt);
      }

      state.deckName = deckSelect.value;
      refreshCategories();
    }

    function refreshCategories() {
      const decks = window.INTERPRETATION_DECKS || {};
      const deck = decks[deckSelect.value] || [];

      const cats = unique(deck.map(q => q.category).filter(Boolean)).sort();

      categorySelect.innerHTML = "";
      const allOpt = document.createElement("option");
      allOpt.value = "__ALL__";
      allOpt.textContent = "All categories";
      categorySelect.appendChild(allOpt);

      for (const c of cats) {
        const opt = document.createElement("option");
        opt.value = c;
        opt.textContent = c;
        categorySelect.appendChild(opt);
      }

      categorySelect.value = "__ALL__";
      state.category = "__ALL__";
      categorySelect.disabled = false;
    }

    // ---------- Pool/order ----------
    function normalizeQuestion(q) {
      // Expected format:
      // {
      //   category,
      //   img, imgAlt, caption,
      //   prompt,
      //   choices: [{text, hint}, ...]  (usually 4)
      //   answer: "Exact text of correct choice",
      //   explanation: "..."
      // }
      if (!q || typeof q.prompt !== "string") return null;
      if (!Array.isArray(q.choices) || q.choices.length < 2) return null;
      if (typeof q.answer !== "string") return null;

      // Ensure choice objects have text/hint
      const choices = q.choices
        .map(c => {
          if (typeof c === "string") return { text: c, hint: "" };
          if (!c || typeof c.text !== "string") return null;
          return { text: c.text, hint: typeof c.hint === "string" ? c.hint : "" };
        })
        .filter(Boolean);

      if (choices.length < 2) return null;

      return {
        category: q.category || "",
        img: q.img || "",
        imgAlt: q.imgAlt || "Figure for interpretation question",
        caption: q.caption || "",
        prompt: q.prompt,
        choices,
        answer: q.answer,
        explanation: q.explanation || ""
      };
    }

    function buildPool() {
      const decks = window.INTERPRETATION_DECKS || {};
      const deck = decks[state.deckName] || [];
      let pool = deck;

      if (state.category !== "__ALL__") {
        pool = deck.filter(q => q.category === state.category);
      }

      pool = pool.map(normalizeQuestion).filter(Boolean);

      state.pool = pool;
      state.order = shuffle(pool);
      state.idx = 0;
      state.correct = 0;
      state.total = 0;
      state.answered = false;
      state.current = null;
      state.displayChoices = [];

      updatePills("In progress");
      updateScore();
    }

    // ---------- Render ----------
    function clearFeedback() {
      feedbackBox.style.display = "none";
      feedbackBox.className = "feedback";
      feedbackBox.textContent = "";
    }

    function renderCurrent() {
      clearFeedback();

      const q = state.order[state.idx];
      state.current = q;
      state.answered = false;

      if (!q) {
        promptText.textContent = "Done!";
        choicesArea.innerHTML = "";
        submitBtn.disabled = true;
        nextBtn.disabled = true;
        figureWrap.style.display = "none";

        const pct = state.total ? Math.round((state.correct / state.total) * 100) : 0;
        feedbackBox.style.display = "block";
        feedbackBox.className = "feedback ok";
        feedbackBox.textContent = `Finished: ${state.correct}/${state.total} (${pct}%)`;

        updatePills("Finished");
        return;
      }

      const currentNum = state.idx + 1;
      const totalNum = state.order.length;
      progressText.textContent = `Question ${currentNum} of ${totalNum}`;
      categoryText.textContent = `Category: ${q.category || "—"}`;

      // Figure
      if (q.img) {
        figureWrap.style.display = "block";
        figureImg.src = q.img; // path is relative to THIS HTML file
        figureImg.alt = q.imgAlt || "Figure";
        figureCaption.textContent = q.caption || "";
      } else {
        figureWrap.style.display = "none";
        figureImg.removeAttribute("src");
        figureImg.alt = "";
        figureCaption.textContent = "";
      }

      promptText.textContent = q.prompt;

      // Shuffle display order, keep objects
      state.displayChoices = shuffle(q.choices.slice());
      choicesArea.innerHTML = "";

      state.displayChoices.forEach((choiceObj, i) => {
        const id = `ch_${currentNum}_${i}`;
        const safeText = escapeHtml(choiceObj.text);
        const safeHint = escapeHtml(choiceObj.hint || "");

        const div = document.createElement("div");
        div.className = "choice";
        div.innerHTML = `
          <input type="radio" name="choice" id="${id}" value="${safeText}" aria-label="Select answer ${i+1}">
          <div class="choiceMain">
            <div class="choiceTop">
              <label class="choiceText" for="${id}">
                <div><b>${safeText}</b></div>
              </label>
              <button type="button" class="hintBtn" data-hint-for="${id}" ${safeHint ? "" : "disabled"} title="${safeHint ? "Show hint" : "No hint for this option"}">
                Hint
              </button>
            </div>
            <div class="hintBox" id="hint_${id}">${safeHint}</div>
          </div>
        `;
        choicesArea.appendChild(div);
      });

      submitBtn.disabled = true; // enable after selection
      nextBtn.disabled = true;

      updatePills("In progress");
    }

    function getSelectedChoice() {
      const checked = document.querySelector('input[name="choice"]:checked');
      return checked ? checked.value : null;
    }

    // ---------- Actions ----------
    function submitAnswer() {
      if (!state.current || state.answered) return;

      const selected = getSelectedChoice();
      if (!selected) {
        feedbackBox.style.display = "block";
        feedbackBox.className = "feedback bad";
        feedbackBox.textContent = "Pick an answer first.";
        return;
      }

      state.answered = true;
      state.total += 1;

      const correct = (selected === state.current.answer);
      if (correct) state.correct += 1;

      updateScore();

      const exp = state.current.explanation ? ` ${state.current.explanation}` : "";
      feedbackBox.style.display = "block";
      feedbackBox.className = "feedback " + (correct ? "ok" : "bad");
      feedbackBox.textContent = correct
        ? ("Correct." + exp)
        : (`Incorrect. Correct answer: ${state.current.answer}.` + exp);

      submitBtn.disabled = true;
      nextBtn.disabled = false;

      updatePills(correct ? "Correct" : "Try next");
    }

    function nextQuestion() {
      if (!state.current) return;
      state.idx += 1;
      renderCurrent();
    }

    function updatePills(status) {
      statusPill.textContent = status;
    }

    function updateScore() {
      scorePill.textContent = `Score: ${state.correct}/${state.total}`;
    }

    // ---------- Events ----------
    deckSelect.addEventListener("change", () => {
      state.deckName = deckSelect.value;
      refreshCategories();
      // user clicks Start
    });

    categorySelect.addEventListener("change", () => {
      state.category = categorySelect.value;
    });

    startBtn.addEventListener("click", () => {
      state.deckName = deckSelect.value;
      state.category = categorySelect.value;

      buildPool();

      emptyState.style.display = "none";
      gameArea.style.display = "block";
      restartBtn.disabled = false;

      if (state.order.length === 0) {
        figureWrap.style.display = "none";
        promptText.textContent = "No valid questions found for that deck/category.";
        choicesArea.innerHTML = "";
        submitBtn.disabled = true;
        nextBtn.disabled = true;
        updatePills("Empty");
        return;
      }

      renderCurrent();
    });

    restartBtn.addEventListener("click", () => {
      if (!state.deckName) return;
      buildPool();
      renderCurrent();
    });

    submitBtn.addEventListener("click", submitAnswer);
    nextBtn.addEventListener("click", nextQuestion);

    // Enable submit once a choice is selected (event delegation)
    document.addEventListener("change", (e) => {
      if (e.target && e.target.name === "choice") {
        // allow submit when any radio checked
        submitBtn.disabled = false;
      }
    });

    // Hint button toggle (event delegation)
    choicesArea.addEventListener("click", (e) => {
      const btn = e.target.closest(".hintBtn");
      if (!btn) return;
      if (btn.disabled) return;

      const forId = btn.getAttribute("data-hint-for");
      const box = document.getElementById("hint_" + forId);
      if (!box) return;

      const isOpen = box.style.display === "block";
      box.style.display = isOpen ? "none" : "block";
      btn.textContent = isOpen ? "Hint" : "Hide hint";
    });

    // ---------- Boot ----------
    initDecks();
  </script>
</body>
</html>

