<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matching: Term ↔ Definition</title>

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f7fb; color: #111; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    .card {
      background: #fff; border-radius: 14px; padding: 18px;
      box-shadow: 0 8px 24px rgba(0,0,0,.08);
    }
    h1 { margin: 0 0 10px; font-size: 20px; }

    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .topRow { justify-content: space-between; }
    .leftControls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    select, button, .btnLink {
      border: 1px solid #d7dbe6; background: #fff; color: #111;
      border-radius: 10px; padding: 10px 12px; font-size: 14px;
      cursor: pointer; text-decoration: none;
    }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:disabled { opacity: .55; cursor: not-allowed; }

    .small { font-size: 12px; color: #666; }
    .divider { height: 1px; background: #eceff6; margin: 14px 0; }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media (min-width: 860px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }

    .panel {
      border: 1px solid #eceff6;
      background: #fbfcff;
      border-radius: 14px;
      padding: 14px;
    }
    .panel h2 { margin: 0 0 10px; font-size: 14px; color: #333; }

    .termRow {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 10px;
      border-radius: 12px;
      background: #fff;
      border: 1px solid #e7eaf3;
      margin-bottom: 10px;
    }
    .termTop {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .termLabel {
      font-weight: 700;
      font-size: 16px;
      margin-right: 10px;
    }

    .dropZone {
      min-height: 46px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 2px dashed #cfd6ea;
      background: #f6f8ff;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .dropZone.over { border-color: #111; }
    .dropHint { color: #667; font-size: 13px; }
    .droppedChip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: #fff;
      border: 1px solid #d7dbe6;
      font-size: 13px;
    }
    .xBtn {
      border: 1px solid #d7dbe6;
      border-radius: 999px;
      padding: 2px 8px;
      background: #fff;
      cursor: pointer;
      font-size: 12px;
      line-height: 1.2;
    }

    .defs {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 520px) {
      .defs { grid-template-columns: 1fr 1fr; }
    }

    .defCard {
      background: #fff;
      border: 1px solid #d7dbe6;
      border-radius: 12px;
      padding: 12px;
      cursor: grab;
      user-select: none;
    }
    .defCard:active { cursor: grabbing; }

    .defCard.used {
      opacity: .55;
      cursor: not-allowed;
    }

    .status {
      margin-top: 12px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      color: #333;
      font-size: 13px;
    }
    .pill {
      background: #f0f2f8;
      border: 1px solid #e1e5f0;
      padding: 6px 10px;
      border-radius: 999px;
    }

    .ok { border-color: #1f9d55 !important; background: #f3fff7 !important; }
    .bad { border-color: #d64545 !important; background: #fff5f5 !important; }

    .note { margin-top: 8px; font-size: 12px; color: #666; line-height: 1.35; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Matching: Term ↔ Definition</h1>

      <div class="row topRow">
        <div class="leftControls">
          <label class="small">Deck:</label>
          <select id="level">
            <option value="BIOL112_EVOLUTION">Evolution</option>
          </select>

          <button id="newBtn" class="primary">New Round</button>
          <button id="submitBtn">Submit</button>
          <button id="resetBtn" title="Reset score">Reset</button>
        </div>

        <a href="../" class="btnLink" title="Back to Vocab Hub">⬅ Vocab Games</a>
      </div>

      <div class="note">
        Drag a definition onto each term. You’ll get <b>6</b> definitions for <b>4</b> terms (2 are distractors).
      </div>

      <div class="divider"></div>

      <div class="grid">
        <div class="panel">
          <h2>Terms (drop definitions here)</h2>
          <div id="terms"></div>
        </div>

        <div class="panel">
          <h2>Definitions (drag from here)</h2>
          <div id="defs" class="defs"></div>
        </div>
      </div>

      <div class="status">
        <div class="pill">Rounds: <span id="rounds">0</span></div>
        <div class="pill">Correct rounds: <span id="roundsCorrect">0</span></div>
        <div class="pill">Wrong rounds: <span id="roundsWrong">0</span></div>
        <div class="pill">Words loaded: <span id="count">0</span></div>
      </div>
    </div>
  </div>

  <!-- Shared decks + utils (yours) -->
  <script src="../data/decks.js"></script>
  <script src="../data/decks.utils.js"></script>

  <script>
    // ==============================
    // Progress + storage
    // ==============================
    let progress = JSON.parse(localStorage.getItem("progress") || "{}");

    function itemKey(item) { return `${item.de}|||${item.en}`; }

    function getItemState(item) {
      return progress[itemKey(item)] || { status: "new", seen: 0, correct: 0, wrong: 0 };
    }

    function setItemState(item, patch) {
      const k = itemKey(item);
      const cur = getItemState(item);
      progress[k] = { ...cur, ...patch };
      localStorage.setItem("progress", JSON.stringify(progress));
    }

    // weights for mastery states (same spirit as your quiz cards)
    function weightForStatus(status) {
      if (status === "known") return 0.05;
      if (status === "learning") return 2.0;
      if (status === "practice") return 6.0;
      return 3.5; // new
    }

    function weightedPick(list) {
      const weights = list.map(item => weightForStatus(getItemState(item).status));
      const total = weights.reduce((a,b)=>a+b,0);
      if (total <= 0.001) return list[Math.floor(Math.random()*list.length)];
      let r = Math.random() * total;
      for (let i=0;i<list.length;i++){
        r -= weights[i];
        if (r <= 0) return list[i];
      }
      return list[list.length-1];
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function uniqueBy(arr, keyFn) {
      const seen = new Set();
      const out = [];
      for (const x of arr) {
        const k = keyFn(x);
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(x);
      }
      return out;
    }

    // ==============================
    // App state
    // ==============================
    let currentTerms = [];        // 4 items: {de,en}
    let currentDefPool = [];      // 6 strings (definitions)
    let assignment = {};          // termKey -> defText
    let usedDefs = new Set();     // defText used

    let rounds = 0;
    let roundsCorrect = 0;
    let roundsWrong = 0;

    // ==============================
    // Data helpers
    // ==============================
    function getLevelList() {
      const level = document.getElementById("level").value;
      const list = getDeck(level);
      const base = dedupePairs(list);

      // prefer not-known unless too small
      const filtered = base.filter(item => getItemState(item).status !== "known");
      return filtered.length >= 6 ? filtered : base;
    }

    function termId(item) {
      return itemKey(item);
    }

    function renderStats() {
      document.getElementById("rounds").textContent = rounds;
      document.getElementById("roundsCorrect").textContent = roundsCorrect;
      document.getElementById("roundsWrong").textContent = roundsWrong;
      document.getElementById("count").textContent = getLevelList().length;
    }

    // ==============================
    // UI render
    // ==============================
    function renderRound() {
      const termsEl = document.getElementById("terms");
      const defsEl = document.getElementById("defs");
      termsEl.innerHTML = "";
      defsEl.innerHTML = "";

      // TERMS
      for (const item of currentTerms) {
        const row = document.createElement("div");
        row.className = "termRow";
        row.dataset.termid = termId(item);

        const top = document.createElement("div");
        top.className = "termTop";

        const label = document.createElement("div");
        label.className = "termLabel";
        label.textContent = item.de;

        // optional mastery buttons per-term (quick + useful)
        const buttons = document.createElement("div");
        buttons.className = "row";
        buttons.style.gap = "8px";

        const knowBtn = document.createElement("button");
        knowBtn.textContent = "I know this";
        knowBtn.title = "Show very rarely";
        knowBtn.addEventListener("click", () => {
          setItemState(item, { status: "known" });
          // new round so it drops out naturally
          newRound();
        });

        const practiceBtn = document.createElement("button");
        practiceBtn.textContent = "Need practice";
        practiceBtn.title = "Show more often";
        practiceBtn.addEventListener("click", () => {
          setItemState(item, { status: "practice" });
          // keep going; no need to refresh
          renderStats();
        });

        buttons.appendChild(knowBtn);
        buttons.appendChild(practiceBtn);

        top.appendChild(label);
        top.appendChild(buttons);

        const drop = document.createElement("div");
        drop.className = "dropZone";
        drop.dataset.termid = termId(item);
        drop.innerHTML = `<span class="dropHint">Drop a definition here</span>`;

        drop.addEventListener("dragover", (e) => {
          e.preventDefault();
          drop.classList.add("over");
        });

        drop.addEventListener("dragleave", () => drop.classList.remove("over"));

        drop.addEventListener("drop", (e) => {
          e.preventDefault();
          drop.classList.remove("over");
          const defText = e.dataTransfer.getData("text/plain");
          if (!defText) return;
          if (usedDefs.has(defText)) return; // already used somewhere else
          setAssignment(item, defText);
        });

        row.appendChild(top);
        row.appendChild(drop);
        termsEl.appendChild(row);
      }

      // DEFINITIONS
      for (const defText of currentDefPool) {
        const card = document.createElement("div");
        card.className = "defCard";
        card.draggable = true;
        card.textContent = defText;
        card.dataset.def = defText;

        card.addEventListener("dragstart", (e) => {
          if (usedDefs.has(defText)) {
            e.preventDefault();
            return;
          }
          e.dataTransfer.setData("text/plain", defText);
        });

        defsEl.appendChild(card);
      }

      refreshUsedStyles();
      renderStats();
    }

    function refreshUsedStyles() {
      // update definition cards
      document.querySelectorAll(".defCard").forEach(el => {
        const defText = el.dataset.def;
        if (usedDefs.has(defText)) el.classList.add("used");
        else el.classList.remove("used");
      });

      // update drop zones
      document.querySelectorAll(".dropZone").forEach(drop => {
        const tid = drop.dataset.termid;
        const defText = assignment[tid];

        drop.classList.remove("ok", "bad");
        drop.innerHTML = "";

        if (!defText) {
          drop.innerHTML = `<span class="dropHint">Drop a definition here</span>`;
          return;
        }

        const chip = document.createElement("span");
        chip.className = "droppedChip";
        chip.textContent = defText;

        const x = document.createElement("button");
        x.className = "xBtn";
        x.type = "button";
        x.textContent = "×";
        x.title = "Remove this match";
        x.addEventListener("click", () => {
          // free up this definition
          usedDefs.delete(defText);
          delete assignment[tid];
          refreshUsedStyles();
        });

        chip.appendChild(x);
        drop.appendChild(chip);
      });
    }

    function setAssignment(item, defText) {
      const tid = termId(item);

      // if that term already had an assignment, free it up
      const old = assignment[tid];
      if (old) usedDefs.delete(old);

      assignment[tid] = defText;
      usedDefs.add(defText);
      refreshUsedStyles();
    }

    // ==============================
    // Round generation
    // ==============================
    function newRound() {
      const list = getLevelList();
      if (list.length < 6) {
        alert("Need at least 6 words in this deck for 4 terms + 2 distractors.");
        return;
      }

      // reset
      assignment = {};
      usedDefs = new Set();

      // pick 4 terms (weighted; avoid duplicates)
      const picked = [];
      const pool = list.slice();

      while (picked.length < 4) {
        const item = weightedPick(pool);
        // ensure uniqueness by key
        if (!picked.some(x => termId(x) === termId(item))) {
          picked.push(item);
        }
        // small guard to prevent infinite loop
        if (picked.length < 4 && pool.length > 10) {
          // reduce chance of repeats by lightly removing
          pool.splice(pool.findIndex(x => termId(x) === termId(item)), 1);
        }
      }

      currentTerms = picked;

      // build definition pool: all 4 correct + 2 distractors
      const correctDefs = currentTerms.map(i => i.en);

      // distractor candidates: definitions not in correct set
      const distractorCandidates = list
        .filter(i => !correctDefs.includes(i.en))
        .map(i => i.en);

      const uniqueDistractors = uniqueBy(distractorCandidates, x => x);
      const distractors = shuffle(uniqueDistractors).slice(0, 2);

      currentDefPool = shuffle([...correctDefs, ...distractors]);

      // wipe any previous correctness coloring
      renderRound();
    }

    // ==============================
    // Submit + scoring
    // ==============================
    function submitRound() {
      // require all 4 matched
      const allMatched = currentTerms.every(item => assignment[termId(item)]);
      if (!allMatched) {
        alert("Match all 4 terms before submitting.");
        return;
      }

      rounds += 1;

      let allCorrect = true;

      for (const item of currentTerms) {
        const tid = termId(item);
        const chosen = assignment[tid];
        const correct = item.en;

        const drop = document.querySelector(`.dropZone[data-termid="${CSS.escape(tid)}"]`);
        if (!drop) continue;

        if (chosen === correct) {
          drop.classList.add("ok");

          const st = getItemState(item);
          const nextStatus =
            st.status === "known"
              ? "known"
              : (st.status === "practice" ? "learning" : st.status);

          setItemState(item, {
            seen: st.seen + 1,
            correct: st.correct + 1,
            wrong: st.wrong,
            status: nextStatus
          });
        } else {
          drop.classList.add("bad");
          allCorrect = false;

          const st = getItemState(item);
          setItemState(item, {
            seen: st.seen + 1,
            correct: st.correct,
            wrong: st.wrong + 1,
            status: "practice" // wrong -> practice
          });
        }
      }

      if (allCorrect) roundsCorrect += 1;
      else roundsWrong += 1;

      renderStats();
    }

    // ==============================
    // Controls
    // ==============================
    document.getElementById("newBtn").addEventListener("click", newRound);
    document.getElementById("submitBtn").addEventListener("click", submitRound);

    document.getElementById("resetBtn").addEventListener("click", () => {
      rounds = 0; roundsCorrect = 0; roundsWrong = 0;
      // keep progress by default; if you want to wipe progress too, uncomment:
      // localStorage.removeItem("progress"); progress = {};
      newRound();
    });

    document.getElementById("level").addEventListener("change", newRound);

    // Boot
    renderStats();
    newRound();
  </script>
</body>
</html>
