<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matching: Term ↔ Definition</title>

  <style>
    /* =========================
       THEME (DARK, same as Flashcards)
       ========================= */
    :root{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      --bg: #0b0f19;
      --card: #0f1629;
      --panel: #111a2e;

      --text: #e8eefc;
      --muted: #aeb9d6;

      --border: #223255;
      --borderSoft: rgba(255,255,255,.10);

      --btnBg: #111a2e;
      --btnText: #e8eefc;
      --btnBorder: #223255;

      --primaryBg: #e8eefc;
      --primaryText: #0b0f19;

      --good: #1f9d55;
      --bad: #d64545;
    }

    body{ margin:0; background:var(--bg); color:var(--text); }
    .wrap{ max-width: 980px; margin: 0 auto; padding: 18px; }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    h1{ margin:0 0 10px; font-size:20px; letter-spacing:.2px; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .topRow{ justify-content:space-between; }
    .leftControls{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .rowRight{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .small{ font-size:12px; color:var(--muted); }
    .divider{ height:1px; background:var(--borderSoft); margin:14px 0; }

    select, button, .btnLink{
      border: 1px solid var(--btnBorder);
      background: var(--btnBg);
      color: var(--btnText);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
      text-decoration: none;
      line-height: 1;
    }

    button.primary{
      background: var(--primaryBg);
      color: var(--primaryText);
      border-color: var(--primaryBg);
      font-weight: 800;
    }

    button.ghost{
      background: transparent;
      border: 1px solid var(--btnBorder);
      color: var(--btnText);
    }

    button:disabled{ opacity:.55; cursor:not-allowed; }

    .note{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    /* Layout grid */
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    @media (min-width: 860px){
      .grid{ grid-template-columns: 1fr 1fr; }
    }

    .panel{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 14px;
      padding: 14px;
    }
    .panel h2{
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--text);
      opacity: .9;
    }

    #toolsPanel{ margin-top: 10px; }

    /* Terms list */
    .termRow{
      display:grid;
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.03);
      border: 1px solid var(--border);
      margin-bottom: 10px;
    }

    .termTop{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    .termLabel{
      font-weight: 800;
      font-size: 16px;
      margin-right: 10px;
    }

    .dropZone{
      min-height: 46px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 2px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .dropZone.over{ border-color: var(--text); }
    .dropHint{ color: var(--muted); font-size: 13px; }

    .droppedChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.03);
      border: 1px solid var(--border);
      font-size: 13px;
    }

    .xBtn{
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 2px 8px;
      background: transparent;
      color: var(--text);
      cursor:pointer;
      font-size: 12px;
      line-height: 1.2;
    }

    /* Definitions */
    .defs{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 520px){
      .defs{ grid-template-columns: 1fr 1fr; }
    }

    .defCard{
      background: rgba(255,255,255,.03);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      cursor: grab;
      user-select:none;
    }
    .defCard:active{ cursor: grabbing; }
    .defCard.used{ opacity:.55; cursor:not-allowed; }

    /* Status pills */
    .status{
      margin-top: 12px;
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 13px;
    }
    .pill{
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
    }

    .ok{ border-color: var(--good) !important; background: rgba(31,157,85,.12) !important; }
    .bad{ border-color: var(--bad) !important; background: rgba(214,69,69,.12) !important; }

    /* Weak panel */
    .weakPanel{
      margin-top: 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 14px;
      padding: 12px;
      display: none;
    }
    .weakTitle{ font-weight: 900; margin-bottom: 6px; }
    .weakSub{ color: var(--muted); font-size: 12px; margin-bottom: 8px; }
    .weakGrid{ display:grid; gap:10px; }
    @media (min-width: 860px){
      .weakGrid{ grid-template-columns: 1fr 1fr; }
    }
    .weakBox{
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,.03);
      font-size: 13px;
    }
    .weakBox b{ display:block; margin-bottom: 6px; }
    .smallmuted{ color: var(--muted); font-size: 12px; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Matching: Term ↔ Definition</h1>

      <div class="row topRow">
        <div class="leftControls">
          <label class="small">Deck:</label>
          <select id="level">
            <option value="BIOL112_EVOLUTION">Evolution</option>
            <option value="BIOL112_Genetics">Genes and Cells</option>
          </select>

          <button id="newBtn" class="primary">New Round</button>
          <button id="submitBtn" class="ghost">Submit</button>
        </div>

        <div class="rowRight">
          <button id="toolsToggle" class="ghost" aria-expanded="false">More ▾</button>
          <a href="../" class="btnLink" title="Back to Vocab Hub">⬅ Vocab Games</a>
        </div>
      </div>

      <!-- TOOLS PANEL (hidden by default) -->
      <div id="toolsPanel" class="panel" hidden>
        <div class="row">
          <button id="reshuffleBtn" class="ghost">Reshuffle 20</button>
          <button id="resetBtn" class="ghost" title="Reset score">Reset score</button>
          <button id="weakBtn" class="ghost">Weak Concepts</button>
          <button id="studyWeakBtn" class="ghost">Study Weak Tags</button>
          <button id="resetStatsBtn" class="ghost">Reset Tracker</button>
        </div>

        <div class="small" style="margin-top:8px; line-height:1.35;">
          Tip: Use <b>Weak Concepts</b> after you’ve played a few rounds—it's based on saved accuracy stats in this browser.
        </div>
      </div>

      <div class="note">
        You are playing with a <b>20-card set</b>. Each round uses <b>4</b> terms + <b>2</b> distractors (6 definitions total).
      </div>

      <div class="divider"></div>

      <!-- WEAK CONCEPTS PANEL -->
      <div id="weakPanel" class="weakPanel">
        <div class="weakTitle">Weak Concepts</div>
        <div class="weakSub">Based on your saved accuracy stats in this browser.</div>

        <div class="weakGrid">
          <div class="weakBox">
            <b>Weakest tags</b>
            <div id="weakTagsList" class="smallmuted">—</div>
          </div>

          <div class="weakBox">
            <b>Most missed cards</b>
            <div id="weakCardsList" class="smallmuted">—</div>
          </div>
        </div>

        <div style="margin-top:10px;" class="smallmuted">
          Tip: “Study Weak Tags” rebuilds your 20-card hand from your 3 weakest tags (when enough data exists).
        </div>
      </div>

      <div class="grid">
        <div class="panel">
          <h2>Terms (drop definitions here)</h2>
          <div id="terms"></div>
        </div>

        <div class="panel">
          <h2>Definitions (drag from here)</h2>
          <div id="defs" class="defs"></div>
        </div>
      </div>

      <div class="status">
        <div class="pill">Rounds: <span id="rounds">0</span></div>
        <div class="pill">Correct rounds: <span id="roundsCorrect">0</span></div>
        <div class="pill">Wrong rounds: <span id="roundsWrong">0</span></div>
        <div class="pill">Words loaded: <span id="count">0</span></div>
      </div>
    </div>
  </div>

  <!-- Shared decks + utils (yours) -->
  <script src="../data/decks.js"></script>
  <script src="../data/decks.utils.js"></script>

  <script>
    // ==============================
    // Panel toggle helpers
    // ==============================
    function setToggleLabel(btn, isOpen, baseText) {
      btn.setAttribute("aria-expanded", String(isOpen));
      btn.textContent = `${baseText} ${isOpen ? "▴" : "▾"}`;
    }

    function togglePanel(btn, panel) {
      const isHidden = panel.hasAttribute("hidden");
      if (isHidden) panel.removeAttribute("hidden");
      else panel.setAttribute("hidden", "");

      const base = btn.textContent.replace(/[▴▾]/g, "").trim();
      setToggleLabel(btn, isHidden, base);
    }

    function closeTools() {
      const btn = document.getElementById("toolsToggle");
      const panel = document.getElementById("toolsPanel");
      if (!btn || !panel) return;
      panel.setAttribute("hidden", "");
      setToggleLabel(btn, false, "More");
    }

    // ==============================
    // Progress + storage (mastery)
    // ==============================
    let progress = JSON.parse(localStorage.getItem("progress") || "{}");

    function itemKey(item) { return `${item.de}|||${item.en}`; }

    function getItemState(item) {
      return progress[itemKey(item)] || { status: "new", seen: 0, correct: 0, wrong: 0 };
    }

    function setItemState(item, patch) {
      const k = itemKey(item);
      const cur = getItemState(item);
      progress[k] = { ...cur, ...patch };
      localStorage.setItem("progress", JSON.stringify(progress));
    }

    // ==============================
    // Tracker helpers (from decks.utils.js)
    // ==============================
    function hasTracker() {
      return !!(window.DECK_UTILS && typeof DECK_UTILS.recordAttempt === "function");
    }

    function trackerRecord(item, isCorrect) {
      if (!hasTracker()) return;
      DECK_UTILS.recordAttempt(item, isCorrect);
    }

    // ==============================
    // weights for mastery states
    // ==============================
    function weightForStatus(status) {
      if (status === "known") return 0.05;
      if (status === "learning") return 2.0;
      if (status === "practice") return 6.0;
      return 3.5; // new
    }

    function weightedPick(list) {
      const weights = list.map(item => weightForStatus(getItemState(item).status));
      const total = weights.reduce((a,b)=>a+b,0);
      if (total <= 0.001) return list[Math.floor(Math.random()*list.length)];
      let r = Math.random() * total;
      for (let i=0;i<list.length;i++){
        r -= weights[i];
        if (r <= 0) return list[i];
      }
      return list[list.length-1];
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function uniqueBy(arr, keyFn) {
      const seen = new Set();
      const out = [];
      for (const x of arr) {
        const k = keyFn(x);
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(x);
      }
      return out;
    }

    // ==============================
    // App state
    // ==============================
    const HAND_SIZE = 20;
    let hand = [];

    let currentTerms = [];
    let currentDefPool = [];
    let assignment = {};
    let usedDefs = new Set();

    let rounds = 0;
    let roundsCorrect = 0;
    let roundsWrong = 0;

    // Weak-tags study mode
    let weakStudyOn = false;
    let weakStudyTags = [];

    // ==============================
    // Data helpers
    // ==============================
    function getFullPool() {
      const level = document.getElementById("level").value;

      const base = (typeof dedupePairs === "function" && typeof getDeck === "function")
        ? dedupePairs(getDeck(level))
        : (window.DECKS && Array.isArray(window.DECKS[level]) ? window.DECKS[level] : []);

      const filtered = base.filter(item => getItemState(item).status !== "known");
      return filtered.length >= 6 ? filtered : base;
    }

    function getBaseDeckUnfiltered() {
      const level = document.getElementById("level").value;
      const base = (typeof dedupePairs === "function" && typeof getDeck === "function")
        ? dedupePairs(getDeck(level))
        : (window.DECKS && Array.isArray(window.DECKS[level]) ? window.DECKS[level] : []);
      return base;
    }

    function termId(item) {
      return itemKey(item);
    }

    function renderStats() {
      document.getElementById("rounds").textContent = rounds;
      document.getElementById("roundsCorrect").textContent = roundsCorrect;
      document.getElementById("roundsWrong").textContent = roundsWrong;
      document.getElementById("count").textContent = hand.length;
    }

    // ==============================
    // Build / reshuffle the 20-card hand
    // ==============================
    function buildNewHand() {
      let pool = getFullPool();
      if (pool.length < 6) {
        alert("Need at least 6 words in this deck.");
        hand = pool.slice();
        renderStats();
        return;
      }

      if (weakStudyOn && weakStudyTags.length) {
        pool = pool.filter(c => weakStudyTags.includes(String(c.tag || "Untagged")));
        if (pool.length < 6) {
          weakStudyOn = false;
          weakStudyTags = [];
          pool = getFullPool();
        }
      }

      if (typeof getRandomCards === "function") {
        hand = getRandomCards(pool, HAND_SIZE);
      } else if (window.DECK_UTILS && typeof DECK_UTILS.getRandomCards === "function") {
        hand = DECK_UTILS.getRandomCards(pool, { count: HAND_SIZE });
      } else {
        hand = shuffle(pool).slice(0, Math.min(HAND_SIZE, pool.length));
      }

      renderStats();
    }

    // ==============================
    // UI render
    // ==============================
    function renderRound() {
      const termsEl = document.getElementById("terms");
      const defsEl = document.getElementById("defs");
      termsEl.innerHTML = "";
      defsEl.innerHTML = "";

      for (const item of currentTerms) {
        const row = document.createElement("div");
        row.className = "termRow";
        row.dataset.termid = termId(item);

        const top = document.createElement("div");
        top.className = "termTop";

        const label = document.createElement("div");
        label.className = "termLabel";
        label.textContent = item.de;

        const buttons = document.createElement("div");
        buttons.className = "row";
        buttons.style.gap = "8px";

        const knowBtn = document.createElement("button");
        knowBtn.className = "ghost";
        knowBtn.textContent = "I know this";
        knowBtn.title = "Show very rarely";
        knowBtn.addEventListener("click", () => {
          setItemState(item, { status: "known" });
          newRound();
        });

        const practiceBtn = document.createElement("button");
        practiceBtn.className = "ghost";
        practiceBtn.textContent = "Need practice";
        practiceBtn.title = "Show more often";
        practiceBtn.addEventListener("click", () => {
          setItemState(item, { status: "practice" });
          renderStats();
        });

        buttons.appendChild(knowBtn);
        buttons.appendChild(practiceBtn);

        top.appendChild(label);
        top.appendChild(buttons);

        const drop = document.createElement("div");
        drop.className = "dropZone";
        drop.dataset.termid = termId(item);
        drop.innerHTML = `<span class="dropHint">Drop a definition here</span>`;

        drop.addEventListener("drop", (e) => {
          e.preventDefault();
          drop.classList.remove("over");
          const defText = e.dataTransfer.getData("text/plain");
          if (!defText) return;

          if (usedDefs.has(defText)) {
            const oldTid = Object.keys(assignment).find(tid => assignment[tid] === defText);
            if (oldTid) {
              delete assignment[oldTid];
              usedDefs.delete(defText);
            }
          }
          setAssignment(item, defText);
        });

        drop.addEventListener("dragover", (e) => { e.preventDefault(); drop.classList.add("over"); });
        drop.addEventListener("dragleave", () => drop.classList.remove("over"));

        row.appendChild(top);
        row.appendChild(drop);
        termsEl.appendChild(row);
      }

      for (const defText of currentDefPool) {
        const card = document.createElement("div");
        card.className = "defCard";
        card.draggable = true;
        card.textContent = defText;
        card.dataset.def = defText;

        card.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("text/plain", defText);
          e.dataTransfer.effectAllowed = "move";
        });

        defsEl.appendChild(card);
      }

      refreshUsedStyles();
      renderStats();
    }

    function refreshUsedStyles() {
      document.querySelectorAll(".defCard").forEach(el => {
        const defText = el.dataset.def;
        if (usedDefs.has(defText)) el.classList.add("used");
        else el.classList.remove("used");
      });

      document.querySelectorAll(".dropZone").forEach(drop => {
        const tid = drop.dataset.termid;
        const defText = assignment[tid];

        drop.classList.remove("ok", "bad");
        drop.innerHTML = "";

        if (!defText) {
          drop.innerHTML = `<span class="dropHint">Drop a definition here</span>`;
          return;
        }

        const chip = document.createElement("span");
        chip.className = "droppedChip";
        chip.textContent = defText;

        const x = document.createElement("button");
        x.className = "xBtn";
        x.type = "button";
        x.textContent = "×";
        x.title = "Remove this match";
        x.addEventListener("click", () => {
          usedDefs.delete(defText);
          delete assignment[tid];
          refreshUsedStyles();
        });

        chip.appendChild(x);
        drop.appendChild(chip);
      });
    }

    function setAssignment(item, defText) {
      const tid = termId(item);
      const old = assignment[tid];
      if (old) usedDefs.delete(old);

      assignment[tid] = defText;
      usedDefs.add(defText);
      refreshUsedStyles();
    }

    // ==============================
    // Round generation (FROM THE HAND ONLY)
    // ==============================
    function newRound() {
      if (!hand || hand.length < 6) buildNewHand();
      if (!hand || hand.length < 6) {
        alert("Need at least 6 words in this deck for 4 terms + 2 distractors.");
        return;
      }

      assignment = {};
      usedDefs = new Set();

      const picked = [];
      const pool = hand.slice();

      let guard = 0;
      while (picked.length < 4 && guard < 200) {
        guard++;
        const item = weightedPick(pool);
        if (!picked.some(x => termId(x) === termId(item))) picked.push(item);
      }

      currentTerms = (picked.length < 4) ? shuffle(hand).slice(0, 4) : picked;

      const correctDefs = currentTerms.map(i => i.en);

      const distractorCandidates = hand
        .filter(i => !correctDefs.includes(i.en))
        .map(i => i.en);

      const distractors = shuffle(uniqueBy(distractorCandidates, x => x)).slice(0, 2);

      let defPool = [...correctDefs, ...distractors];

      if (defPool.length < 6) {
        const fullPool = getFullPool()
          .map(i => i.en)
          .filter(en => !defPool.includes(en));
        defPool = defPool.concat(shuffle(uniqueBy(fullPool, x => x)).slice(0, 6 - defPool.length));
      }

      currentDefPool = shuffle(defPool).slice(0, 6);
      renderRound();
    }

    // ==============================
    // Submit + scoring + TRACKER
    // ==============================
    function submitRound() {
      const allMatched = currentTerms.every(item => assignment[termId(item)]);
      if (!allMatched) {
        alert("Match all 4 terms before submitting.");
        return;
      }

      rounds += 1;
      let allCorrect = true;

      for (const item of currentTerms) {
        const tid = termId(item);
        const chosen = assignment[tid];
        const correct = item.en;

        const drop = document.querySelector(`.dropZone[data-termid="${CSS.escape(tid)}"]`);
        if (!drop) continue;

        const isCorrect = (chosen === correct);
        trackerRecord(item, isCorrect);

        if (isCorrect) {
          drop.classList.add("ok");

          const st = getItemState(item);
          const nextStatus =
            st.status === "known" ? "known" :
            (st.status === "practice" ? "learning" : st.status);

          setItemState(item, {
            seen: st.seen + 1,
            correct: st.correct + 1,
            wrong: st.wrong,
            status: nextStatus
          });
        } else {
          drop.classList.add("bad");
          allCorrect = false;

          const st = getItemState(item);
          setItemState(item, {
            seen: st.seen + 1,
            correct: st.correct,
            wrong: st.wrong + 1,
            status: "practice"
          });
        }
      }

      if (allCorrect) roundsCorrect += 1;
      else roundsWrong += 1;

      renderStats();

      const wp = document.getElementById("weakPanel");
      if (wp.style.display === "block") showWeakPanel();
    }

    // ==============================
    // Weak concepts UI
    // ==============================
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    function showWeakPanel() {
      const panel = document.getElementById("weakPanel");
      const tagsEl = document.getElementById("weakTagsList");
      const cardsEl = document.getElementById("weakCardsList");

      panel.style.display = "block";

      if (!hasTracker()) {
        tagsEl.innerHTML = "Tracker not loaded. Make sure your decks.utils.js exposes <b>window.DECK_UTILS</b> with tracker functions.";
        cardsEl.innerHTML = "—";
        return;
      }

      const baseDeck = getBaseDeckUnfiltered();

      const weakTags = DECK_UTILS.getWeakTags(baseDeck, { minAttemptsPerTag: 5 });
      const weakCards = DECK_UTILS.getWeakCards(baseDeck, { limit: 10, minAttempts: 2, includeUnseen: true });

      if (!weakTags.length) {
        tagsEl.innerHTML = "Not enough data yet. Play a few rounds first.";
      } else {
        tagsEl.innerHTML = weakTags.slice(0, 6).map(t => {
          const pct = (t.pct == null) ? "—" : `${Math.round(t.pct * 100)}%`;
          return `• <b>${escapeHtml(t.tag)}</b>: ${pct} (${t.correct}/${t.attempts})`;
        }).join("<br>");
      }

      if (!weakCards.length) {
        cardsEl.innerHTML = "Not enough data yet.";
      } else {
        cardsEl.innerHTML = weakCards.map(row => {
          const pct = (row.pct == null) ? "—" : `${Math.round(row.pct * 100)}%`;
          const label = row.card && row.card.de ? row.card.de : "(missing term)";
          return `• <b>${escapeHtml(label)}</b>: ${pct} (${row.correct}/${row.attempts})`;
        }).join("<br>");
      }
    }

    function activateWeakStudyMode() {
      if (!hasTracker()) {
        alert("Tracker not loaded. Replace decks.utils.js with the tracker version first.");
        return;
      }

      const baseDeck = getBaseDeckUnfiltered();
      const weakTags = DECK_UTILS.getWeakTags(baseDeck, { minAttemptsPerTag: 5 });

      if (!weakTags.length) {
        alert("Not enough data yet for weak tags—play a few rounds first.");
        return;
      }

      weakStudyTags = weakTags.slice(0, 3).map(t => t.tag);
      weakStudyOn = true;

      buildNewHand();
      newRound();
      showWeakPanel();
      closeTools();
    }

    // ==============================
    // Controls
    // ==============================
    document.getElementById("toolsToggle").addEventListener("click", () => {
      togglePanel(
        document.getElementById("toolsToggle"),
        document.getElementById("toolsPanel")
      );
    });

    document.getElementById("newBtn").addEventListener("click", () => newRound());
    document.getElementById("submitBtn").addEventListener("click", () => submitRound());

    document.getElementById("reshuffleBtn").addEventListener("click", () => {
      buildNewHand();
      newRound();
      closeTools();
    });

    document.getElementById("resetBtn").addEventListener("click", () => {
      rounds = 0; roundsCorrect = 0; roundsWrong = 0;
      renderStats();
      newRound();
      closeTools();
    });

    document.getElementById("level").addEventListener("change", () => {
      weakStudyOn = false;
      weakStudyTags = [];
      buildNewHand();
      newRound();
      closeTools();
    });

    document.getElementById("weakBtn").addEventListener("click", () => {
      showWeakPanel();
      closeTools();
    });

    document.getElementById("studyWeakBtn").addEventListener("click", () => {
      activateWeakStudyMode();
    });

    document.getElementById("resetStatsBtn").addEventListener("click", () => {
      if (!hasTracker()) { alert("Tracker not loaded."); return; }
      if (!confirm("Reset accuracy tracker stats for this browser?")) return;
      DECK_UTILS.resetTracker();
      const panel = document.getElementById("weakPanel");
      if (panel.style.display === "block") showWeakPanel();
      closeTools();
    });

    // Boot
    renderStats();
    buildNewHand();
    newRound();
  </script>
</body>
</html>
